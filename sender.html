<!DOCTYPE html>
<html lang="en">
<head>
    <title>Sender</title>
    <script src="https://cdn.socket.io/4.0.1/socket.io.min.js"></script>
</head>
<body>
    <h2>Send a File</h2>
    <input type="file" id="fileInput">
    <button onclick="sendFile()">Send File</button>
    <p id="status">Waiting for connection...</p>

    <script>
        const socket = io("https://file-transfer-mfru.onrender.com/", { transports: ["websocket"] });

        const peerConnection = new RTCPeerConnection();
        let dataChannel;

        function createDataChannel() {
            dataChannel = peerConnection.createDataChannel("fileTransfer");

            dataChannel.onopen = () => {
                console.log("‚úÖ Data channel is open!");
                document.getElementById("status").innerText = "Connected! Ready to send file.";
            };

            dataChannel.onclose = () => {
                console.log("‚ö† Data channel closed.");
                document.getElementById("status").innerText = "Connection lost.";
            };
        }

        async function startConnection() {
            createDataChannel();
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            socket.emit("offer", offer);
        }

        // socket.on("answer", async (data) => {
        //     await peerConnection.setRemoteDescription(new RTCSessionDescription(data));
        // });


        socket.on("answer", async (data) => {
            if (peerConnection.signalingState !== "stable") {
          console.warn("‚ö† Ignoring answer because the connection is not stable.");
                return;
                     }
              await peerConnection.setRemoteDescription(new RTCSessionDescription(data));
                                                });

        socket.on("candidate", (candidate) => {
            peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        });

        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                socket.emit("candidate", event.candidate);
            }
        };

        async function sendFile() {
            if (!dataChannel || dataChannel.readyState !== "open") {
                alert("‚ö† Data channel is not ready yet! Please wait.");
                return;
            }

            const file = document.getElementById("fileInput").files[0];
            if (!file) {
                alert("Select a file first!");
                return;
            }

            document.getElementById("status").innerText = "Sending...";
            console.log(`üì§ Sending file: ${file.name} (${file.size} bytes)`);

            dataChannel.send(JSON.stringify({ type: "file-info", size: file.size }));

            const chunkSize = 256 * 1024; // 16 KB
            let offset = 0;

            function sendChunk() {
    if (offset >= file.size) {
        dataChannel.send("EOF");
        console.log("‚úÖ File transfer complete!");
        document.getElementById("status").innerText = "File Sent!";
        return;
    }

    const reader = new FileReader();
    reader.onload = () => {
        if (dataChannel.readyState === "open") {
            // Wait for the buffer to clear before sending
            if (dataChannel.bufferedAmount > 0) {
                console.log("‚è≥ Buffer is full, waiting...");
                setTimeout(sendChunk, 100); // Wait and retry
                return;
            }

            dataChannel.send(reader.result);
            offset += chunkSize;

            const progress = ((offset / file.size) * 100).toFixed(2);
            console.log(`üìä Sending progress: ${progress}%`);
            document.getElementById("status").innerText = `Sending: ${progress}%`;

            sendChunk();
        } else {
            console.log("‚ö† Data channel closed unexpectedly.");
        }
    };

    reader.readAsArrayBuffer(file.slice(offset, offset + chunkSize));
}

            sendChunk();
        }

        startConnection();
    </script>
</body>
</html>
